<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>JS Tetris (ìµœì¢… ìˆ˜ì • ë²„ì „)</title>
    <style>
        /* ====================
           CSS ìŠ¤íƒ€ì¼
           ==================== */
        :root {
            --board-width: 10;
            --board-height: 20;
            --cell-size: 30px;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #282c34;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            flex-direction: column;
        }

        .game-container {
            display: flex;
            gap: 30px;
            padding: 20px;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-width), var(--cell-size));
            grid-template-rows: repeat(var(--board-height), var(--cell-size));
            border: 5px solid #555;
            background-color: #111;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #000;
            box-sizing: border-box;
            transition: background-color 0.1s;
        }

        /* ë¸”ë¡ ìƒ‰ìƒ ì •ì˜ */
        .cell.i { background-color: #00ffff; border-color: #008080; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.j { background-color: #0000ff; border-color: #000080; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.l { background-color: #ffa500; border-color: #805200; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.o { background-color: #ffff00; border-color: #808000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.s { background-color: #00ff00; border-color: #008000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.t { background-color: #800080; border-color: #400040; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.z { background-color: #ff0000; border-color: #800000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        
        .info-panel {
            width: 150px;
        }

        .hidden {
            display: none !important;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid red;
            z-index: 100;
        }
        
        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>

    <h1>JavaScript Tetris</h1>
    <div class="game-container">
        <div id="game-board" class="grid">
            </div>

        <div class="info-panel">
            <h2>ì ìˆ˜: <span id="score">0</span></h2>
            <h3>ì¡°ì‘ë²•:</h3>
            <p>â†, â†’: ì´ë™</p>
            <p>â†‘: íšŒì „</p>
            <p>â†“: ë¹ ë¥´ê²Œ í•˜ê°•</p>
        </div>
    </div>

    <div id="game-over" class="hidden">
        <h1>GAME OVER</h1>
        <p>ìµœì¢… ì ìˆ˜: <span id="final-score">0</span></p>
        <button onclick="startGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        /* ====================
           JavaScript ë¡œì§
           ==================== */

        // ğŸ§± ìƒìˆ˜ ì •ì˜
        const COLS = 10;
        const ROWS = 20;
        const board = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const gameOverPanel = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const cells = []; 
        
        // ğŸ§± ë³´ë“œ ìƒíƒœ: ê³ ì •ëœ ë¸”ë¡ì„ ì €ì¥ (0ì€ ë¹ˆ ì¹¸, ê·¸ ì™¸ëŠ” ë¸”ë¡ ìƒ‰ìƒ í´ë˜ìŠ¤ ë¬¸ìì—´)
        let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

        // ğŸ§± í…ŒíŠ¸ë¡œë¯¸ë…¸ í˜•íƒœì™€ ìƒ‰ìƒ ì •ì˜
        const TETROMINOS = [
            { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: 'i' },
            { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: 'j' },
            { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: 'l' },
            { shape: [[1, 1], [1, 1]], color: 'o' },
            { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: 's' },
            { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: 't' },
            { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: 'z' }
        ];

        let currentPiece; 
        let score = 0;
        let gameInterval;
        let isGameOver = false;

        // ===================================
        // 1. ì´ˆê¸°í™” ë° ìœ í‹¸ë¦¬í‹°
        // ===================================

        function createBoard() {
            for (let i = 0; i < ROWS * COLS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                board.appendChild(cell);
                cells.push(cell);
            }
        }
        
        function getCell(x, y) {
            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                return cells[y * COLS + x];
            }
            return null;
        }

        // ===================================
        // 2. ë¸”ë¡ ê·¸ë¦¬ê¸° ë° DOM ì—…ë°ì´íŠ¸
        // ===================================

        function updateDOMCell(x, y, colorClass) {
            const cell = getCell(x, y);
            if (cell) {
                // ê¸°ì¡´ ìƒ‰ìƒ í´ë˜ìŠ¤ ì œê±° í›„ ìƒˆ ìƒ‰ìƒ í´ë˜ìŠ¤ ì ìš©
                cell.className = 'cell'; 
                if (colorClass !== 0) {
                    cell.classList.add(colorClass);
                }
            }
        }

        // Grid ìƒíƒœì™€ í˜„ì¬ ë¸”ë¡ì„ ëª¨ë‘ ë°˜ì˜í•˜ì—¬ ë³´ë“œë¥¼ ê·¸ë¦½ë‹ˆë‹¤.
        function drawBoard() {
            // 1. ê³ ì •ëœ ë¸”ë¡ (Grid) ê·¸ë¦¬ê¸°
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    updateDOMCell(x, y, grid[y][x]);
                }
            }

            // 2. ì›€ì§ì´ëŠ” ë¸”ë¡ (CurrentPiece) ê·¸ë¦¬ê¸°
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    if (cellValue === 1) {
                        const x = currentPiece.x + colIndex;
                        const y = currentPiece.y + rowIndex;
                        
                        // í˜„ì¬ ë¸”ë¡ì€ Gridì˜ ë‚´ìš©ê³¼ ìƒê´€ì—†ì´ ê·¸ë ¤ì ¸ì•¼ í•©ë‹ˆë‹¤.
                        updateDOMCell(x, y, currentPiece.color);
                    }
                });
            });
        }
        
        // ===================================
        // 3. ì¶©ëŒ ê²€ì‚¬
        // ===================================

        function isValidMove(newX, newY, newShape) {
            for (let rowIndex = 0; rowIndex < newShape.length; rowIndex++) {
                for (let colIndex = 0; colIndex < newShape[0].length; colIndex++) {
                    if (newShape[rowIndex][colIndex] === 1) {
                        const x = newX + colIndex;
                        const y = newY + rowIndex;

                        // 1. ë²½ ì¶©ëŒ ê²€ì‚¬
                        if (x < 0 || x >= COLS || y >= ROWS) {
                            return false;
                        }
                        
                        // 2. ë‹¤ë¥¸ ê³ ì •ëœ ë¸”ë¡ê³¼ì˜ ì¶©ëŒ ê²€ì‚¬ (Gridì— ìƒ‰ìƒì´ ìˆëŠ” ê²½ìš°)
                        if (y >= 0 && grid[y][x] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // ===================================
        // 4. ê²Œì„ ë¡œì§
        // ===================================

        function move(newX, newY, newShape) {
            if (isValidMove(newX, newY, newShape)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                currentPiece.shape = newShape; 
                drawBoard();
                return true;
            }
            return false;
        }

        function rotate() {
            const rows = currentPiece.shape.length;
            const cols = currentPiece.shape[0].length;
            let newShape = Array.from({ length: cols }, () => Array(rows).fill(0));

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    newShape[j][rows - 1 - i] = currentPiece.shape[i][j];
                }
            }
            
            // íšŒì „ ì‹œë„ (ì¶©ëŒ ì‹œ íšŒì „ ì·¨ì†Œ)
            move(currentPiece.x, currentPiece.y, newShape);
        }

        function moveDown() {
            if (isGameOver) return;
            
            // ì•„ë˜ë¡œ ì´ë™ ì„±ê³µ
            if (move(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                return;
            }
            
            // ì´ë™ ì‹¤íŒ¨ (ë°”ë‹¥ ë˜ëŠ” ë¸”ë¡ ì¶©ëŒ) -> ê³ ì • ë° ë‹¤ìŒ ë‹¨ê³„
            freeze();
            checkLines();
            spawnPiece();
        }

        // ë¸”ë¡ ê³ ì • ë° Grid ì—…ë°ì´íŠ¸:
        // ì›€ì§ì´ë˜ ë¸”ë¡ì„ Grid ë°°ì—´ì— ì˜êµ¬ì ìœ¼ë¡œ ê¸°ë¡í•©ë‹ˆë‹¤.
        function freeze() {
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    if (cellValue === 1) {
                        const x = currentPiece.x + colIndex;
                        const y = currentPiece.y + rowIndex;
                        
                        if (y >= 0) {
                             grid[y][x] = currentPiece.color; // ìƒ‰ìƒ ë¬¸ìì—´ ì €ì¥
                        }
                    }
                });
            });
        }

        // ì¤„ ì œê±° ë° Grid ì—…ë°ì´íŠ¸
        function checkLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                // í˜„ì¬ í–‰ì´ ëª¨ë‘ ì±„ì›Œì¡ŒëŠ”ì§€ í™•ì¸ (ëª¨ë“  ì…€ì´ 0ì´ ì•„ë‹˜)
                if (grid[y].every(cell => cell !== 0)) {
                    linesCleared++;
                    
                    // í•´ë‹¹ í–‰ì„ Gridì—ì„œ ì œê±°í•˜ê³ , ë§¨ ìœ„ì— ìƒˆë¡œìš´ ë¹ˆ í–‰ì„ ì¶”ê°€
                    grid.splice(y, 1);
                    grid.unshift(Array(COLS).fill(0)); 
                    
                    // í–‰ì´ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ, ê°™ì€ y ìœ„ì¹˜ë¥¼ ë‹¤ì‹œ ê²€ì‚¬í•´ì•¼ í•©ë‹ˆë‹¤.
                    y++; 
                }
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100 * linesCleared;
                scoreDisplay.innerText = score;
                drawBoard(); // Gridê°€ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ ë³´ë“œë¥¼ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
            }
        }

        function spawnPiece() {
            const random = Math.floor(Math.random() * TETROMINOS.length);
            const piece = TETROMINOS[random];

            currentPiece = {
                shape: piece.shape,
                color: piece.color,
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0 
            };
            
            if (!isValidMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                gameOver();
                return;
            }
            
            drawBoard();
        }

        function gameOver() {
            clearInterval(gameInterval);
            document.removeEventListener('keydown', control);
            finalScoreDisplay.innerText = score;
            gameOverPanel.classList.remove('hidden');
            isGameOver = true;
        }

        function control(e) {
            if (isGameOver) return;
            
            let newX = currentPiece.x;
            let newY = currentPiece.y;

            if (e.key === 'ArrowLeft') {
                newX--;
                move(newX, newY, currentPiece.shape);
            } else if (e.key === 'ArrowRight') {
                newX++;
                move(newX, newY, currentPiece.shape);
            } else if (e.key === 'ArrowDown') {
                moveDown(); 
            } else if (e.key === 'ArrowUp') {
                rotate();
            }
        }

        function startGame() {
            // ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            cells.forEach(cell => cell.className = 'cell'); // DOM ì´ˆê¸°í™”
            score = 0;
            scoreDisplay.innerText = score;
            isGameOver = false;
            gameOverPanel.classList.add('hidden');

            spawnPiece();

            // ê²Œì„ ë£¨í”„ ì‹œì‘
            clearInterval(gameInterval);
            gameInterval = setInterval(moveDown, 500);

            document.addEventListener('keydown', control);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ
        createBoard();
        startGame();

    </script>
</body>
</html>
