<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>JS Tetris (í†µí•© ì½”ë“œ)</title>
    <style>
        /* ====================
           CSS (style.css í†µí•©)
           ==================== */
        :root {
            --board-width: 10;  /* ê²Œì„ ë³´ë“œì˜ ë„ˆë¹„ (ì…€ ê°œìˆ˜) */
            --board-height: 20; /* ê²Œì„ ë³´ë“œì˜ ë†’ì´ (ì…€ ê°œìˆ˜) */
            --cell-size: 30px;  /* ê° ì…€ì˜ í¬ê¸° */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #282c34;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            flex-direction: column;
        }

        .game-container {
            display: flex;
            gap: 30px;
            padding: 20px;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #game-board {
            display: grid;
            /* CSS Gridë¥¼ ì‚¬ìš©í•˜ì—¬ 10x20 ê²©ìë¥¼ ë§Œë“­ë‹ˆë‹¤. */
            grid-template-columns: repeat(var(--board-width), var(--cell-size));
            grid-template-rows: repeat(var(--board-height), var(--cell-size));
            border: 5px solid #555;
            background-color: #111;
        }

        .cell {
            /* ê° ì…€ì˜ ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #000;
            box-sizing: border-box; /* íŒ¨ë”©ê³¼ ë³´ë”ë¥¼ ë„ˆë¹„/ë†’ì´ì— í¬í•¨ */
        }

        /* ë¸”ë¡ ìƒ‰ìƒ ì •ì˜ (JavaScriptì—ì„œ ì´ í´ë˜ìŠ¤ë“¤ì„ ì…€ì— ì¶”ê°€í•©ë‹ˆë‹¤) */
        .cell.i { background-color: cyan; border-color: #00ffff; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.j { background-color: blue; border-color: #0000ff; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.l { background-color: orange; border-color: #ffa500; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.o { background-color: yellow; border-color: #ffff00; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.s { background-color: lime; border-color: #00ff00; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.t { background-color: purple; border-color: #800080; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.z { background-color: red; border-color: #ff0000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }

        .info-panel {
            width: 150px;
        }

        .hidden {
            display: none !important;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid red;
        }

        #game-over h1 {
            color: red;
        }
        
        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }

    </style>
</head>
<body>

    <h1>T-Block Test Game</h1>
    <div class="game-container">
        <div id="game-board" class="grid">
            </div>

        <div class="info-panel">
            <h2>ì ìˆ˜: <span id="score">0</span></h2>
            <h3>ì¡°ì‘ë²•:</h3>
            <p>â†, â†’: ì´ë™</p>
            <p>â†“: í•˜ê°• (í˜„ì¬ëŠ” ìë™)</p>
            <p>â†‘: íšŒì „ (ë¯¸êµ¬í˜„)</p>
            </div>
    </div>

    <div id="game-over" class="hidden">
        <h1>GAME OVER</h1>
        <button onclick="startGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        /* ====================
           JavaScript (main.js í†µí•©)
           ==================== */

        // ğŸ§± ìƒìˆ˜ ì •ì˜
        const COLS = 10;
        const ROWS = 20;
        const board = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const gameOverPanel = document.getElementById('game-over');
        const cells = []; // ê²Œì„ ë³´ë“œì˜ ëª¨ë“  ì…€ì„ ë‹´ì„ ë°°ì—´ (DOM ìš”ì†Œ)

        // T ë¸”ë¡ í˜•íƒœ ì •ì˜ (4x4 ê²©ì ê¸°ì¤€)
        const TETROMINOS = [
            // ì—¬ê¸°ì„œëŠ” T ë¸”ë¡ í•˜ë‚˜ë§Œ ì •ì˜í•˜ê³  ì‚¬ìš©í•©ë‹ˆë‹¤.
            {
                shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
                color: 't'
            },
        ];

        let currentPiece; // í˜„ì¬ ì›€ì§ì´ëŠ” ë¸”ë¡ ê°ì²´ { shape, color, x, y }
        let score = 0;
        let gameInterval;
        let isGameOver = false;

        // 1. ê²Œì„ ë³´ë“œ ì´ˆê¸°í™” ë° ìƒì„±
        function createBoard() {
            for (let i = 0; i < ROWS * COLS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                board.appendChild(cell);
                cells.push(cell);
            }
        }

        // íŠ¹ì • ì¢Œí‘œ (x, y)ì˜ ì…€ DOM ìš”ì†Œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
        function getCell(x, y) {
            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                return cells[y * COLS + x];
            }
            return null; // ë³´ë“œ ë°”ê¹¥
        }

        // 2. ë¸”ë¡ ê·¸ë¦¬ê¸°/ì§€ìš°ê¸°
        function draw() {
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    if (cellValue === 1) {
                        const x = currentPiece.x + colIndex;
                        const y = currentPiece.y + rowIndex;
                        const cell = getCell(x, y);
                        if (cell) {
                            cell.classList.add(currentPiece.color);
                        }
                    }
                });
            });
        }

        function undraw() {
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    if (cellValue === 1) {
                        const x = currentPiece.x + colIndex;
                        const y = currentPiece.y + rowIndex;
                        const cell = getCell(x, y);
                        if (cell) {
                            cell.classList.remove(currentPiece.color);
                        }
                    }
                });
            });
        }

        // 3. ì¶©ëŒ ê²€ì‚¬
        function isValidMove(newX, newY, newShape) {
            for (let rowIndex = 0; rowIndex < newShape.length; rowIndex++) {
                for (let colIndex = 0; colIndex < newShape[0].length; colIndex++) {
                    if (newShape[rowIndex][colIndex] === 1) {
                        const x = newX + colIndex;
                        const y = newY + rowIndex;

                        // 1. ë²½ ì¶©ëŒ ê²€ì‚¬
                        if (x < 0 || x >= COLS || y >= ROWS) {
                            return false;
                        }
                        
                        // 2. ë‹¤ë¥¸ ë¸”ë¡ê³¼ì˜ ì¶©ëŒ ê²€ì‚¬ (í˜„ì¬ëŠ” êµ¬í˜„ì´ ê°„ë‹¨í•˜ì—¬ ìƒëµ. ì‹¤ì œ ê²Œì„ì—ì„  í•„ìš”)
                        const cell = getCell(x, y);
                        if (cell && cell.classList.length > 1) { // 'cell' í´ë˜ìŠ¤ ì™¸ì— ë‹¤ë¥¸ í´ë˜ìŠ¤ê°€ ìˆë‹¤ë©´ ê³ ì •ëœ ë¸”ë¡
                            // y < 0ì€ ì²œì¥ ì¶©ëŒ ê²€ì‚¬ (ê²Œì„ ì˜¤ë²„ ì¡°ê±´)
                            if (y >= 0) {
                                return false; 
                            }
                        }
                    }
                }
            }
            return true;
        }

        // 4. ë¸”ë¡ í•˜ê°•
        function moveDown() {
            if (isGameOver) return;

            undraw();
            
            // í•œ ì¹¸ ì•„ë˜ë¡œ ì´ë™ì´ ê°€ëŠ¥í•œì§€ í™•ì¸
            if (isValidMove(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                currentPiece.y++;
                draw();
            } else {
                // ë” ì´ìƒ ë‚´ë ¤ê°ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ê³ ì •
                freeze();
                checkLines();
                spawnPiece(); // ìƒˆ ë¸”ë¡ ìƒì„±
                
                // ìƒˆ ë¸”ë¡ ìƒì„± í›„ ë°”ë¡œ ì¶©ëŒ(ê²Œì„ ì˜¤ë²„) í™•ì¸
                if (!isValidMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                    gameOver();
                }
            }
        }

        // 5. ë¸”ë¡ ê³ ì • (ë³´ë“œì— ì˜êµ¬ì ìœ¼ë¡œ ë‚¨ê¹€)
        function freeze() {
            // í˜„ì¬ ì˜ˆì œì—ì„œëŠ” draw()ë¥¼ í–ˆê¸° ë•Œë¬¸ì— ì…€ì— í´ë˜ìŠ¤ê°€ ë‚¨ì•„ìˆì–´ ê³ ì • ì²˜ë¦¬ê°€ ì™„ë£Œë©ë‹ˆë‹¤.
            // ì‹¤ì œ ë³µì¡í•œ ê²Œì„ì—ì„œëŠ” ë³´ë“œ ìƒíƒœ(2ì°¨ì› ë°°ì—´)ë¥¼ ì—…ë°ì´íŠ¸ í•˜ëŠ” ê³¼ì •ì´ ì¶”ê°€ë©ë‹ˆë‹¤.
        }

        // 6. ì¤„ ì œê±° (ê°„ë‹¨ êµ¬í˜„)
        function checkLines() {
            // ì‹¤ì œ ì¤„ ì œê±° ë¡œì§ì€ ë³µì¡í•˜ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” ì ìˆ˜ë§Œ ê°„ë‹¨íˆ ì—…ë°ì´íŠ¸
            score += 10; 
            scoreDisplay.innerText = score;
        }

        // 7. ìƒˆ ë¸”ë¡ ìƒì„±
        function spawnPiece() {
            const random = Math.floor(Math.random() * TETROMINOS.length);
            const piece = TETROMINOS[random];

            currentPiece = {
                shape: piece.shape,
                color: piece.color,
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0 // ë§¨ ìœ„ì—ì„œ ì‹œì‘
            };
            draw();
        }

        // 8. ê²Œì„ ì˜¤ë²„
        function gameOver() {
            clearInterval(gameInterval);
            document.removeEventListener('keydown', control);
            gameOverPanel.classList.remove('hidden');
            isGameOver = true;
        }

        // 9. í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤ (ì¢Œìš° ì´ë™ë§Œ ê°„ë‹¨ êµ¬í˜„)
        function control(e) {
            if (isGameOver) return;
            
            let newX = currentPiece.x;
            
            if (e.key === 'ArrowLeft') {
                newX--;
            } else if (e.key === 'ArrowRight') {
                newX++;
            }
            // else if (e.key === 'ArrowUp') { /* íšŒì „ ë¡œì§ */ }

            if (isValidMove(newX, currentPiece.y, currentPiece.shape)) {
                undraw();
                currentPiece.x = newX;
                draw();
            }
        }

        // 10. ê²Œì„ ì‹œì‘
        function startGame() {
            // ë³´ë“œ ì´ˆê¸°í™”
            cells.forEach(cell => cell.className = 'cell');
            score = 0;
            scoreDisplay.innerText = score;
            isGameOver = false;
            gameOverPanel.classList.add('hidden');

            // ì²« ë¸”ë¡ ìƒì„±
            spawnPiece();

            // ê²Œì„ ë£¨í”„ ì‹œì‘ (ì˜ˆ: 800msë§ˆë‹¤ í•˜ê°•)
            clearInterval(gameInterval);
            gameInterval = setInterval(moveDown, 800);

            // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            document.addEventListener('keydown', control);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ
        createBoard();
        startGame();

    </script>
</body>
</html>
