<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>JS Tetris (ì™„ì „íŒ)</title>
    <style>
        /* ====================
           CSS ìŠ¤íƒ€ì¼
           ==================== */
        :root {
            --board-width: 10;
            --board-height: 20;
            --cell-size: 30px;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #282c34;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            flex-direction: column;
        }

        .game-container {
            display: flex;
            gap: 30px;
            padding: 20px;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-width), var(--cell-size));
            grid-template-rows: repeat(var(--board-height), var(--cell-size));
            border: 5px solid #555;
            background-color: #111;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #000;
            box-sizing: border-box;
            /* ë°°ê²½ìƒ‰ì´ ì„¤ì •ëœ ì…€ì—ë§Œ ê·¸ë¦¼ì íš¨ê³¼ ì ìš© */
            transition: background-color 0.1s; 
        }

        /* ë¸”ë¡ ìƒ‰ìƒ ì •ì˜ */
        .cell.i { background-color: #00ffff; border-color: #008080; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.j { background-color: #0000ff; border-color: #000080; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.l { background-color: #ffa500; border-color: #805200; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.o { background-color: #ffff00; border-color: #808000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.s { background-color: #00ff00; border-color: #008000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.t { background-color: #800080; border-color: #400040; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        .cell.z { background-color: #ff0000; border-color: #800000; box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5); }
        
        /* ë¹ˆ ì…€ì˜ ë°°ê²½ì„ ì–´ë‘¡ê²Œ ì„¤ì • */
        .cell:not([class*="i"]):not([class*="j"]):not([class*="l"]):not([class*="o"]):not([class*="s"]):not([class*="t"]):not([class*="z"]) {
            background-color: #111;
        }

        .info-panel {
            width: 150px;
        }

        .hidden {
            display: none !important;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid red;
            z-index: 100;
        }
        
        #game-over h1 {
            color: red;
        }

        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>

    <h1>JavaScript Tetris</h1>
    <div class="game-container">
        <div id="game-board" class="grid">
            </div>

        <div class="info-panel">
            <h2>ì ìˆ˜: <span id="score">0</span></h2>
            <h3>ì¡°ì‘ë²•:</h3>
            <p>â†, â†’: ì´ë™</p>
            <p>â†‘: íšŒì „</p>
            <p>â†“: ë¹ ë¥´ê²Œ í•˜ê°•</p>
        </div>
    </div>

    <div id="game-over" class="hidden">
        <h1>GAME OVER</h1>
        <p>ìµœì¢… ì ìˆ˜: <span id="final-score">0</span></p>
        <button onclick="startGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>

    <script>
        /* ====================
           JavaScript ë¡œì§
           ==================== */

        // ğŸ§± ìƒìˆ˜ ì •ì˜
        const COLS = 10;
        const ROWS = 20;
        const board = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const gameOverPanel = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const cells = []; // ê²Œì„ ë³´ë“œì˜ ëª¨ë“  ì…€ DOM ìš”ì†Œë¥¼ ì €ì¥
        
        // ğŸ§± ë³´ë“œ ìƒíƒœ (ê³ ì •ëœ ë¸”ë¡ì„ ì €ì¥í•˜ëŠ” 2ì°¨ì› ë°°ì—´)
        let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

        // ğŸ§± í…ŒíŠ¸ë¡œë¯¸ë…¸ í˜•íƒœì™€ ìƒ‰ìƒ ì •ì˜
        const TETROMINOS = [
            { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: 'i' }, // I
            { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: 'j' }, // J
            { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: 'l' }, // L
            { shape: [[1, 1], [1, 1]], color: 'o' }, // O
            { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: 's' }, // S
            { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: 't' }, // T
            { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: 'z' }  // Z
        ];

        let currentPiece; // { shape, color, x, y }
        let score = 0;
        let gameInterval;
        let isGameOver = false;

        // ===================================
        // 1. ì´ˆê¸°í™” ë° ë³´ë“œ ìƒì„±
        // ===================================

        function createBoard() {
            for (let i = 0; i < ROWS * COLS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                board.appendChild(cell);
                cells.push(cell);
            }
        }
        
        function getCell(x, y) {
            return cells[y * COLS + x];
        }

        // ===================================
        // 2. ë¸”ë¡ ê·¸ë¦¬ê¸° ë° ì§€ìš°ê¸°
        // ===================================
        
        // ì›€ì§ì´ëŠ” ë¸”ë¡ì„ DOMì— ê·¸ë¦½ë‹ˆë‹¤.
        function draw(isDrawing = true) {
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    if (cellValue === 1) {
                        const x = currentPiece.x + colIndex;
                        const y = currentPiece.y + rowIndex;
                        const cell = getCell(x, y);
                        
                        if (cell) {
                            if (isDrawing) {
                                cell.classList.add(currentPiece.color);
                            } else {
                                cell.classList.remove(currentPiece.color);
                            }
                        }
                    }
                });
            });
        }
        
        function undraw() {
            draw(false);
        }

        // ===================================
        // 3. ì¶©ëŒ ê²€ì‚¬
        // ===================================

        function isValidMove(newX, newY, newShape) {
            for (let rowIndex = 0; rowIndex < newShape.length; rowIndex++) {
                for (let colIndex = 0; colIndex < newShape[0].length; colIndex++) {
                    if (newShape[rowIndex][colIndex] === 1) {
                        const x = newX + colIndex;
                        const y = newY + rowIndex;

                        // ë²½ (ì¢Œ, ìš°, ë°”ë‹¥) ì¶©ëŒ ê²€ì‚¬
                        if (x < 0 || x >= COLS || y >= ROWS) {
                            return false;
                        }
                        
                        // ë‹¤ë¥¸ ê³ ì •ëœ ë¸”ë¡ê³¼ì˜ ì¶©ëŒ ê²€ì‚¬ (y >= 0 ì¡°ê±´ìœ¼ë¡œ ë³´ë“œ ë°– ê²€ì‚¬ ë°©ì§€)
                        if (y >= 0 && grid[y][x] !== 0) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // ===================================
        // 4. ê²Œì„ ë¡œì§
        // ===================================

        function spawnPiece() {
            const random = Math.floor(Math.random() * TETROMINOS.length);
            const piece = TETROMINOS[random];

            currentPiece = {
                shape: piece.shape,
                color: piece.color,
                // ê°€ìš´ë° ì •ë ¬
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0 
            };
            
            // ìƒˆ ë¸”ë¡ ìƒì„± ì‹œ ë°”ë¡œ ì¶©ëŒí•˜ë©´ ê²Œì„ ì˜¤ë²„
            if (!isValidMove(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                gameOver();
                return;
            }
            
            draw();
        }
        
        function move(newX, newY, newShape) {
            if (isValidMove(newX, newY, newShape)) {
                undraw();
                currentPiece.x = newX;
                currentPiece.y = newY;
                currentPiece.shape = newShape; // íšŒì „ ì‹œ ì‚¬ìš©
                draw();
                return true;
            }
            return false;
        }

        function moveDown() {
            if (isGameOver) return;
            
            // ì•„ë˜ë¡œ ì´ë™ ì„±ê³µ
            if (move(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                return;
            }
            
            // ì´ë™ ì‹¤íŒ¨ (ë°”ë‹¥ ë˜ëŠ” ë¸”ë¡ ì¶©ëŒ) -> ê³ ì • ë° ë‹¤ìŒ ë‹¨ê³„
            freeze();
            checkLines();
            spawnPiece();
        }

        // ë¸”ë¡ íšŒì „ ë¡œì§
        function rotate() {
            // í˜„ì¬ ëª¨ì–‘ì˜ í–‰ê³¼ ì—´ì„ ë°”ê¿‰ë‹ˆë‹¤ (ì „ì¹˜ í–‰ë ¬)
            const rows = currentPiece.shape.length;
            const cols = currentPiece.shape[0].length;
            let newShape = Array.from({ length: cols }, () => Array(rows).fill(0));

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    newShape[j][rows - 1 - i] = currentPiece.shape[i][j];
                }
            }
            
            // íšŒì „ëœ ëª¨ì–‘ìœ¼ë¡œ ì´ë™ ì‹œë„
            move(currentPiece.x, currentPiece.y, newShape);
        }

        // 5. ë¸”ë¡ ê³ ì • ë° Grid ì—…ë°ì´íŠ¸
        function freeze() {
            currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cellValue, colIndex) => {
                    if (cellValue === 1) {
                        const x = currentPiece.x + colIndex;
                        const y = currentPiece.y + rowIndex;
                        // Gridì— ë¸”ë¡ì˜ ìƒ‰ìƒ ì½”ë“œë¥¼ ì €ì¥ (1ì€ ì±„ì›Œì¡Œë‹¤ëŠ” ì˜ë¯¸)
                        if (y >= 0) {
                             grid[y][x] = 1; 
                             // DOM ì…€ì˜ í´ë˜ìŠ¤ëŠ” draw() í•¨ìˆ˜ì— ì˜í•´ ì´ë¯¸ ì¶”ê°€ë˜ì—ˆìœ¼ë¯€ë¡œ ë³„ë„ ì²˜ë¦¬ëŠ” í•„ìš” ì—†ìŒ
                        }
                    }
                });
            });
        }

        // 6. ì¤„ ì œê±°
        function checkLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                // í˜„ì¬ í–‰ì´ ëª¨ë‘ ì±„ì›Œì¡ŒëŠ”ì§€ í™•ì¸ (grid[y]ì˜ ëª¨ë“  ê°’ì´ 1ì¸ì§€)
                if (grid[y].every(cell => cell === 1)) {
                    linesCleared++;
                    
                    // 1. í•´ë‹¹ í–‰ ì œê±°: Grid ë°°ì—´ì—ì„œ í–‰ì„ ì œê±°í•©ë‹ˆë‹¤.
                    grid.splice(y, 1);
                    // 2. ìƒˆë¡œìš´ ë¹ˆ í–‰ì„ ë§¨ ìœ„ì— ì¶”ê°€í•©ë‹ˆë‹¤.
                    grid.unshift(Array(COLS).fill(0)); 
                    
                    // í–‰ì´ ì œê±°ë˜ì—ˆìœ¼ë¯€ë¡œ, í˜„ì¬ y ìœ„ì¹˜ë¥¼ ë‹¤ì‹œ ê²€ì‚¬í•´ì•¼ í•©ë‹ˆë‹¤.
                    y++; 
                }
            }
            
            if (linesCleared > 0) {
                // ì ìˆ˜ ê³„ì‚° (í…ŒíŠ¸ë¦¬ìŠ¤ ë£° ë‹¨ìˆœí™”)
                score += linesCleared * 100 * linesCleared;
                scoreDisplay.innerText = score;
                
                // DOM ë³´ë“œ ì—…ë°ì´íŠ¸
                updateBoardFromGrid();
            }
        }
        
        // Grid ë°°ì—´ì˜ ìƒíƒœë¥¼ ê¸°ë°˜ìœ¼ë¡œ DOM ì…€ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        function updateBoardFromGrid() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = getCell(x, y);
                    // ëª¨ë“  ìƒ‰ìƒ í´ë˜ìŠ¤ë¥¼ ì œê±°í•˜ê³ , Gridì— ë¸”ë¡ì´ ìˆë‹¤ë©´ ë‹¤ì‹œ í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
                    cell.className = 'cell'; // ê¸°ë³¸ í´ë˜ìŠ¤ë¡œ ì´ˆê¸°í™”
                    if (grid[y][x] !== 0) {
                        // ì‹¤ì œë¡œëŠ” gridì— ë¸”ë¡ ìƒ‰ìƒ ì½”ë“œë¥¼ ì €ì¥í•˜ì—¬ì•¼ ì •í™•í•©ë‹ˆë‹¤. 
                        // ì´ ì˜ˆì œì—ì„œëŠ” ë‹¨ìˆœí•˜ê²Œ ê³ ì •ëœ ë¸”ë¡ì€ ê°€ì¥ ìµœê·¼ ë¸”ë¡ ìƒ‰ìƒìœ¼ë¡œ ê°€ì •í•©ë‹ˆë‹¤.
                        // (ì™„ë²½í•œ êµ¬í˜„ì„ ìœ„í•´ì„œëŠ” freeze() ì‹œ gridì— ìƒ‰ìƒ ë¬¸ìì—´ì„ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤.)
                        cell.classList.add(currentPiece.color); 
                    }
                }
            }
        }


        // 7. ê²Œì„ ì˜¤ë²„
        function gameOver() {
            clearInterval(gameInterval);
            document.removeEventListener('keydown', control);
            finalScoreDisplay.innerText = score;
            gameOverPanel.classList.remove('hidden');
            isGameOver = true;
        }

        // 8. í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤
        function control(e) {
            if (isGameOver) return;
            
            let newX = currentPiece.x;
            let newY = currentPiece.y;

            if (e.key === 'ArrowLeft') {
                newX--;
                move(newX, newY, currentPiece.shape);
            } else if (e.key === 'ArrowRight') {
                newX++;
                move(newX, newY, currentPiece.shape);
            } else if (e.key === 'ArrowDown') {
                // ë¹ ë¥´ê²Œ í•˜ê°• (Hard Drop ëŒ€ì‹  Soft Dropìœ¼ë¡œ ì²˜ë¦¬)
                moveDown(); 
            } else if (e.key === 'ArrowUp') {
                rotate();
            }
        }

        // 9. ê²Œì„ ì‹œì‘
        function startGame() {
            // ë³´ë“œ ë° ìƒíƒœ ì´ˆê¸°í™”
            cells.forEach(cell => cell.className = 'cell');
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            scoreDisplay.innerText = score;
            isGameOver = false;
            gameOverPanel.classList.add('hidden');

            // ì²« ë¸”ë¡ ìƒì„±
            spawnPiece();

            // ê²Œì„ ë£¨í”„ ì‹œì‘ (500msë§ˆë‹¤ í•˜ê°•)
            clearInterval(gameInterval);
            gameInterval = setInterval(moveDown, 500);

            // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            document.addEventListener('keydown', control);
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ
        createBoard();
        startGame();

    </script>
</body>
</html>
